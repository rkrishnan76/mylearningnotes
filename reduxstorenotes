In order to create a store, you pass a reducer function to Redux’s createStore() method as the first argument. What’s returned from createStore() is the store itself, which has three properties on it:

getState()
dispatch()
subscribe()
getState()
store.getState() doesn’t take any arguments and will return the current state of the store.
dispatch()
store.dispatch(action) takes in an action object and will call the reducer function, passing it the current state and the action which was dispatched. For example:

// store.js

import { createStore } from 'redux';
import reducer from '../reducers/reducer';

let store = createStore(reducer);

const receiveComment = comment => ({
  type: 'RECEIVE_COMMENT',
  comment
});

export default store;
store.getState(); // []
store.dispatch(receiveComment('Redux is great!'));
store.getState(); // ['Redux is great!']
subscribe()
store.subscribe(cb) takes in a listener callback function that will be invoked whenever the state of the store changes.

What is true about the store in Redux? Select all that apply.
Updates to the store can only be triggered by dispatching actions
The store's subscribe() function helps connect React components to the store
--------------------------
create a reducer that sets the uer array to []
call createstore(reducer)
store.dispatch(adduser)
result=store.getstate
list displays new user
--------------------------
Provider is really just a React component that we use to wrap the entire application. It takes in the store as a prop, then sets the store context, passing it down to all its subcomponents. All components wrapped by Provider will receive the store context
-----------------
Provider makes it possible for Redux to pass data from the store to any React components that need it. It uses React’s context feature to make this work.

Components that need access to the store, however, still need a way to “connect” to it. We mentioned the connect() function earlier, which utilizes a technique in functional programming called currying. Before we see connect() in action, let’s take a closer look at how currying works!
-------------
Currying

Here we have a simple plate() function which takes in two arguments: avegetable and a fruit.

function plate(vegetables, fruit) {
  return `I ate a plate of ${vegetables} and ${fruit}!`;
}

plate('corn', 'apples');
Now say that for whatever reason we want to delay getting the fruit until a later point. One way we could achieve this would be to return a function which accepts the fruit that can be invoked at a later point.

function plate(vegetables) {
  return function fruitFunc (fruit) {
    return `I ate a plate of ${vegetables} and ${fruit}!`;
  }
}

const fruitFunc = plate('corn');
Now we have a fruitFunc() that we can call, pass it a fruit, and the vegetables (corn) are still accessible via closures.

Another way to write this without the delay would be like this:

function plate(vegetables) {
  return function fruitFunc (fruit) {
    return `I ate a plate of ${vegetables} and ${fruit}!`;
  }
}

const sentence = plate('corn')('apples');
It may take a second for your brain to wrap your head around that double invocation, but try to break it down into steps. When you call the plate function, that returns the fruitFunc(), which is then invoked and passed “apples”. This technique is used in functional programming (as well as Redux) and is called currying (also partial application).
------------------------
